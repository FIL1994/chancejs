function initOptions(options = {}, defaults) {
  if (defaults) {
    for (let i in defaults) {
      if (typeof options[i] === "undefined") {
        options[i] = defaults[i];
      }
    }
  }

  return options;
}

/**
 *
 * @param {number} size
 */
function range(size) {
  return Array.apply(null, Array(size)).map(function(_, i) {
    return i;
  });
}

function testRange(test, errorMessage) {
  if (test) {
    throw new RangeError(errorMessage);
  }
}

function copyObject(source, _target) {
  var isArray = Array.isArray(source);
  var target = _target || (isArray ? new Array(source.length) : {});

  if (isArray) {
    _copyArray(source, target);
  } else {
    _copyObject(source, target);
  }

  return target;
}

var o_hasOwnProperty = Object.prototype.hasOwnProperty;
var o_keys =
  Object.keys ||
  function(obj) {
    var result = [];
    for (var key in obj) {
      if (o_hasOwnProperty.call(obj, key)) {
        result.push(key);
      }
    }

    return result;
  };

function _copyObject(source, target) {
  var keys = o_keys(source);
  var key;

  for (var i = 0, l = keys.length; i < l; i++) {
    key = keys[i];
    target[key] = source[key] || target[key];
  }
}

function _copyArray(source, target) {
  for (var i = 0, l = source.length; i < l; i++) {
    target[i] = source[i];
  }
}

/** @param {string} word */
function capitalize(word) {
  return word.charAt(0).toUpperCase() + word.substr(1);
}
/**
 *  Given a function that generates something random and a number of items to generate,
 *    return an array of items where none repeat.
 *
 *  @param {Function} fn the function that generates something random
 *  @param {Number} num number of terms to generate
 *  @param {Object} options any options to pass on to the generator function
 *  @returns {Array} an array of length `num` with every item generated by `fn` and unique
 *
 *  There can be more parameters after these. All additional parameters are provided to the given function
 */
function unique(fn, num, options) {
  testRange(
    typeof fn !== "function",
    "Chance: The first argument must be a function."
  );

  var comparator = function(arr, val) {
    return arr.indexOf(val) !== -1;
  };

  if (options) {
    comparator = options.comparator || comparator;
  }

  var arr = [],
    count = 0,
    result,
    MAX_DUPLICATES = num * 50,
    params = Array.prototype.slice.call(arguments, 2);

  while (arr.length < num) {
    var clonedParams = JSON.parse(JSON.stringify(params));
    result = fn.apply(this, clonedParams);
    if (!comparator(arr, result)) {
      arr.push(result);
      // reset count when unique found
      count = 0;
    }

    if (++count > MAX_DUPLICATES) {
      throw new RangeError("Chance: num is likely too large for sample set");
    }
  }
  return arr;
}

/**
 * @returns {string}
 */
function pad(number, width, pad = "0") {
  number = number + "";
  return number.length >= width
    ? number
    : new Array(width - number.length + 1).join(pad) + number;
}

/** @type {any} */
let base64 = function() {
  throw new Error("No base64 encoder available");
};

if (typeof btoa === "function") {
  base64 = btoa;
} else if (typeof Buffer === "function") {
  base64 = function(input) {
    return new Buffer(input).toString("base64");
  };
}

export {
  testRange,
  initOptions,
  range,
  base64,
  copyObject,
  capitalize,
  unique,
  pad
};
